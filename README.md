# Competitive Programming Preparation Guide

This repository contains resources and implementations for competitive programming algorithms and data structures, organized by difficulty level.

## Tier 1: Core Algorithms (Must Have)

### Sorting Algorithms
- **Merge Sort** - Efficient divide and conquer sorting algorithm with O(n log n) time complexity
- **Quick Sort** - Fast divide and conquer sorting algorithm with average O(n log n) time complexity

### Searching Algorithms
- **Linear Search** - Simple search algorithm with O(n) time complexity
- **Binary Search** - Efficient search in sorted arrays with O(log n) time complexity

### Recursion and Backtracking
- **Basic Recursion** - Understanding recursive function calls
- **Backtracking Fundamentals** - Solving problems by trying possibilities and undoing failed attempts
  - Generating Permutations
  - Generating Subsets
  - Solving Sudoku

## Tier 2: Intermediate Algorithms

### Data Structures
- **Binary Trees** - Tree with at most two children per node
- **Binary Search Trees (BST)** - Ordered binary trees for efficient lookup, insertion, and deletion
- **Heaps** - Specialized tree-based data structure for priority queue operations
- **Tries** - Tree data structure used for efficient retrieval of keys in a dataset of strings
- **Graph Representations** - Adjacency matrix and adjacency list implementations

### Graph Algorithms
- **Breadth-First Search (BFS)** - Level-order traversal of graphs
- **Depth-First Search (DFS)** - Exploring paths in graphs before backtracking
- **Dijkstra's Algorithm** - Finding shortest paths in weighted graphs with non-negative edges
- **Bellman-Ford Algorithm** - Finding shortest paths with possible negative edges
- **Floyd-Warshall Algorithm** - All-pairs shortest path algorithm
- **Minimum Spanning Trees**
  - Kruskal's Algorithm - Using disjoint set union
  - Prim's Algorithm - Using priority queue

### Algorithm Paradigms
- **Dynamic Programming** - Breaking problems down into overlapping subproblems
- **Greedy Algorithms** - Making locally optimal choices at each stage
- **Divide and Conquer** - Breaking problems into non-overlapping subproblems

## Tier 3: Advanced Algorithms (CP, Gives a competitive edge)

### Advanced Data Structures
- **Disjoint Set Union (DSU)** - Also known as Union-Find data structure
- **Segment Trees** - For range query operations with updates
- **Fenwick Trees (Binary Indexed Trees)** - For efficient prefix sum calculations

### String Algorithms
- **Knuth-Morris-Pratt (KMP)** - Efficient string matching algorithm
- **Rabin-Karp Algorithm** - String searching using hashing

### Advanced Graph Algorithms
- **Lowest Common Ancestor (LCA)** - Finding common ancestors in trees
- **Maximum Flow / Minimum Cut** - Network flow algorithms
  - Ford-Fulkerson Algorithm
  - Edmonds-Karp Algorithm
  - Dinic's Algorithm

### Advanced Dynamic Programming
- **DP with Bitmasks** - Using bits to represent states in dynamic programming

## Honorable Mentions (Good to Know)

- **Mo's Algorithm** - Offline query processing with sqrt decomposition
- **Sparse Table** - Data structure for static Range Minimum/Maximum Query (RMQ)
- **Manacher's Algorithm** - Finding all palindromic substrings in linear time
- **Aho-Corasick Algorithm** - String matching for multiple patterns
- **Heavy-Light Decomposition (HLD)** - Tree decomposition technique for path queries
- **LCA with Binary Lifting** - Optimized approach for finding lowest common ancestors
- **Matrix Exponentiation** - Binary exponentiation for matrices, useful for solving recurrence relations

Happy Coding!